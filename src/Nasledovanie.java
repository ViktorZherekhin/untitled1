public class Nasledovanie {
    public static void main(String[] args) {
        Animal anim1 = new Animal();           // мы уже создавали ранее этот класс (см. ClassesAndObjects.java),
                                                // поэтому можем создать объект на его базе
        anim1.eat();            // таким образом наше животное умеет есть и спать
        anim1.sleep();

        Dog dog1 = new Dog();   // после того, как мы указали что класс "Dog" является наследником класса "Animal"
        dog1.eat();             // мы можем применить к объекту класса "Dog" те же методы
        dog1.sleep();           // но для "Dog" вызовется переопределнный метод eat()
        dog1.gavgav();

        // удобство: если у нас будет много разных животных (кошки, птички, рыбки, и т.д.)
        // нам не нужно для каждого прописывать МЕТОДЫ (есть, спать, и т.д.) и ПОЛЯ, а они
        // автоматически унаследуются от родительского класса "Animal"

        dog1.showName();
        System.out.println("--------------");

        // "Позднее связывание"
        Animal anim2 = new Dog();      // это называется "Upcasting"
                                        // здесь объект воспринимаем как родителя "Dog", т.е. получается
                                        // восходящее преобразование от наследника к родителю (неявно)
                                        // собака стала животным
        Dog dog2 = new Dog();       // альтернативный вариант записи
        Animal anim3 = dog2;

        // "Downcasting"
        Dog dog3 = (Dog) anim3;    // т.е. получается нисосходящее преобразование от родителя к потомку (явно)
                                   // животное стало собакой
                                    // это похоже на преобразование примитивных типов данных
                                    // и оно не всегда безопасно, т.к.
                                    // в 1-м случае собака всегда является животным,
                                    // а во 2-м животное не всегда является собакой
        // например:
        Dog dog4 = (Dog) anim1;
        dog4.gavgav();             // здесь будет ощибка "class Animal cannot be cast to class Dog"


        anim2.eat();                // т.е. вызвался переопределенный метод eat()
        System.out.println("----/------/----");

        action(dog1);           // применение Полиморфизма
        action(anim1);          // Достоинства:
                                //    - компактнее код.
                                //    - одно действие на трех различных типах (классах).
    }

    public static void action(Animal animal){
        animal.makeSound();
    }
    // Полиморфизм - это способность одного и того же фрагмента кода работать с разными типами данных
}
